# Choir

## Database

This application uses a database for users and other data. The Diesel ORM is used to integrate
the database.

### Settings

The application is setup to use Postgres as it's database but other database types can theoretically
be used to. A unit like struct `DbConn` is setup as fairing and used to interact with the database. The database
decorator uses the same name as the mentioned environment variable below (`#[database("postgres_db")]`) to
specify which database the application should connect to.

| Environment variable | Data | Description |
|:---------------------|-----:|------------:|
| POSTGRES\_DB         | postgres://username:password@localhost/DB\_demo | Address of the postgers server to use |

Alternatively the variables can also be set within the `Rocket.toml` file.

```
# Within Rocket.toml
[global.databases]
postgres_db = { url = "/path/to/postgerql/database" }
```

Please don't forget to set the `DATABASE_URL` either manually using `export` or
via the `.env` file to use the `diesel_cli` command line interface.

```
// in .env
DATABASE_URL=postgres://username:password@path/to/database
```

### Diesel

First install the __diesel__ command line application.

```
$ cargo install diesel_cli --no-default-features --features postgres
```

Then set the **DATABASE_URL** so diesel knows where to find the database.

```
echo DATABASE_URL=postgres://username:password@localhost/diesel_demo > .env
```

or

```
export  DATABASE_URL=postgres://username:password@localhost/diesel_demo
```

Because the migration directory with all schemas does already exist we don't need
to run the `diesel setup` command.

#### Create new migration

To add or alter tables one can use migrations. To create a new migration you can run
`diesel migration generate migration_name` and then edit the newly created `up.sql` and
`down.sql` files.

#### Running migrations

To run migrations you can execute:

```
diesel migration run
```

To redo all migrations you can execute:

```
diesel migration redo
```

### Tests

All tests for the application can be found in the `choir::tests` module. The `setup_test_db(conn: &PgConnection)`
function is used to setup the database if required. It runs potentially outstanding migrations
and ensures that specific data sets are present in the database. This is done with the help
of the `diesel_migrations` crate and it's `embed_migrations!` macro used in the __crate root__ (lib).

Every test starts with a call to `test_rocket()` which sets-up a rocket instance for testing. Then one can
use the `get_one(&Rocket)` function of the `DbConn` unit struct (generated by the #[database(...)] attribute)
to retrieve the database connection. This connection can then be used throughout the test.

```
let r = test_rocket();
let conn = super::DbConn::get_one(&r).expect("database connection"); // get database connection connected to the rocket instance
setup_test_db(&*conn);
```

## Tests

You can run the tests by executing:

```
cargo test -- --test-threads=1
```

Running the tests with more than one thread may lead
to failing tests due to race conditions, e.g. a user
is deleted while still needed in another test.
