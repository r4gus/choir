use super::rocket;
use rocket::local::Client;
use rocket::http::{Status, ContentType};
use super::models::*;
use super::database::*;
use diesel::PgConnection;

/// Test the login handler.
///
/// # Arguments
///
/// * `user` - The username/ email to submit.
/// * `password` - The password to submit.
/// * `status` - The expected response status after the form has been submitted.
/// * `body` - Part of the expected response (has to implement the Into and Send trait).
///
fn test_login<T>(user: &str, password: &str, status: Status, body: T)
    where T: Into<Option<&'static str>> + Send
{
    let client = Client::new(rocket()).unwrap();
    let query = format!("email={}&password={}", user, password);
    let mut response = client.post("/login")
        .header(ContentType::Form)
        .body(&query)
        .dispatch();

    assert_eq!(response.status(), status);
    if let Some(expected_str) = body.into() {
        if let Some(body_str) = response.body_string() {
            assert!(body_str.contains(expected_str));
        }
    }
}

/// Test login handler using abnormal or incomplete forms.
///
/// # Arguments
///
/// * `form_str` - The form string to test.
/// * `status` - The expected status message.
///
fn test_bad_form(form_str: &str, status: Status) {
    let client = Client::new(rocket()).unwrap();
    let response = client.post("/login")
        .header(ContentType::Form)
        .body(form_str)
        .dispatch();

    assert_eq!(response.status(), status);
}

/// Create a rocket instance for test purposes
fn test_rocket() -> rocket::Rocket {
    rocket()
        .attach(super::DbConn::fairing())
}

/// Setup the attached database.
///
/// Requires a database to be attached.
fn setup_test_db(conn: &PgConnection) {
    let u1 = NewUser {
        email: "david@gmail.com",
        password_hash: "nohash",
        first_name: "David",
        last_name: "Sugar",
        street: "Test Street",
        house_number: "7a",
        zip: "12345",
        city: "IDK",
        phone: "+49 12345",
        is_admin: true,
    };

    super::embedded_migrations::run(conn); // generated by the embed_migrations! macro
    create_user(&u1, conn).is_ok();
}



#[test]
fn login_test() {
    let client = Client::new(rocket()).expect("valid rocket instance");
    let mut response = client.get("/login").dispatch();
    assert_eq!(response.status(), Status::Ok);
}

#[test]
fn test_successful_login() {
    test_login("david@gamil.com", "password", Status::SeeOther, None); // Redirect to dashboard on success
}

#[test]
fn test_bad_form_wrong_number_of_fields() {
    test_bad_form("email=david@web.de", Status::UnprocessableEntity);
    test_bad_form("password=12345", Status::UnprocessableEntity);
    test_bad_form("email=david@web.de&password=12345&cool=true", Status::UnprocessableEntity);
}

#[test]
fn test_bad_form_abnormal() {
    test_bad_form("&&&===&", Status::BadRequest);
    test_bad_form("&&&=password==&", Status::BadRequest);
}

#[test]
fn test_create_user() {
    let r = test_rocket();
    let conn = super::DbConn::get_one(&r).expect("database connection"); // get database connection connected to the rocket instance
    setup_test_db(&*conn);

    let user = get_user_by_mail("david@gmail.com", &*conn);
    assert!(user.is_ok());
    assert_eq!(1, user.unwrap().len());

    let user2 = get_user_by_mail("franzi@gmail.com", &*conn);
    assert!(user2.is_ok());
    assert_eq!(0, user2.unwrap().len());
}
